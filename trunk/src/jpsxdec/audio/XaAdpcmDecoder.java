/*
 * jPSXdec: PlayStation 1 Media Decoder/Converter in Java
 * Copyright (C) 2007-2013  Michael Sabin
 * All rights reserved.
 *
 * Redistribution and use of the jPSXdec code or any derivative works are
 * permitted provided that the following conditions are met:
 *
 *  * Redistributions may not be sold, nor may they be used in commercial
 *    or revenue-generating business activities.
 *
 *  * Redistributions that are modified from the original source must
 *    include the complete source code, including the source code for all
 *    components used by a binary built from the modified sources. However, as
 *    a special exception, the source code distributed need not include
 *    anything that is normally distributed (in either source or binary form)
 *    with the major components (compiler, kernel, and so on) of the operating
 *    system on which the executable runs, unless that component itself
 *    accompanies the executable.
 *
 *  * Redistributions must reproduce the above copyright notice, this list
 *    of conditions and the following disclaimer in the documentation and/or
 *    other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
 * IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
 * OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package jpsxdec.audio;

import java.io.EOFException;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.util.ArrayList;
import java.util.Collections;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.sound.sampled.AudioFormat;
import jpsxdec.util.IO;
import jpsxdec.util.Misc;

/** The ultimate PlayStation (and CD-i) XA ADPCM decoder. Based on the code
 * and documentation by Jonathan Atkins and Jac Goudsmit
 * (http://freshmeat.net/projects/cdxa/).
 *<p>
 * Audio data on the PSX is encoded using a form of
 * Adaptive Differential Pulse Code Modulation (ADPCM).
 *<p>
 * Since the ADPCM data is interleaved you cannot decode as the data is being 
 * read, so the design requires a buffer. All of SoundUnit #1 must be read 
 * before decoding SoundUnit #2. Once all of sound unit #1 has been read, 
 * you've already read all the other sound units anyway.
 *<hr>
 * This class could be designed in one of 5 ways:
 *<ol>
 *<li>The decoder is minimal and writes an array of shorts:
 * (still interleaved stereo because that shouldn't change, but
 * the return of shorts eliminates the need to know about endian-ness)
 * That array of shorts could then be converted to an AudioInputStream
 * by copying to a byte[] array and wrapping with AudioInputStream.
 *<li>Minimal decoder, but writes an array of bytes in the chosen endian order.
 *<li>Minimal decoder, but writes an array of bytes in a predetermined endian order.
 *<li>Decoder does everything and returns an AudioInputStream.
 *<li>Make it work like the rest of the Java audio system and have the class
 *    implement TargetDataLine.
 *</ol>
 * This has been implemented using the 3rd method.
 */
public abstract class XaAdpcmDecoder {

    /**
     * Creates a XA ADPCM decoder for the supplied input format
     * (bits/sample and stereo) and writes the decoded PCM audio with the
     * supplied volume. Audio scaling occurs before clamping for better quality.
     *
     * @param iBitsPerSample  ADPCM bits per sample: either 4 or 8.
     * @param blnIsStereo     true for stereo, false for mono.
     * @param dblVolume       Audio scaled by this amount.
     */
    public static XaAdpcmDecoder create(int iBitsPerSample, boolean blnIsStereo,
                                        double dblVolume)
    {
        if (blnIsStereo)
            return new XaAdpcmDecoder_Stereo(iBitsPerSample, dblVolume);
        else
            return new XaAdpcmDecoder_Mono(iBitsPerSample, dblVolume);
    }

    /** The number of PCM samples generated by a ADPCM audio sector will be
     * 4032 for 4 bits/sample, or 2016 for 8 bits/sample. */
    public static int pcmSamplesGeneratedFromXaAdpcmSector(int iBitsPerSample) {
        switch (iBitsPerSample) {
            case 4: return ADPCM_SOUND_GROUPS_PER_SECTOR * 
                           AdpcmSoundUnit.SAMPLES_PER_SOUND_UNIT *
                           SoundGroup4BitsPerSample.SOUND_UNITS_IN_4_BIT_SECTOR;
            case 8: return ADPCM_SOUND_GROUPS_PER_SECTOR * 
                           AdpcmSoundUnit.SAMPLES_PER_SOUND_UNIT *
                           SoundGroup8BitsPerSample.SOUND_UNITS_IN_8_BIT_SECTOR;
            default: throw new IllegalArgumentException("Invalid bits/sample " + iBitsPerSample);
        }
    }

    /** Number of bytes generated from an XA ADPCM sector will be 8064 for 4
     * bits/sample, or 4032 for 8 bits/sample. */
    public static int bytesGeneratedFromXaAdpcmSector(int iBitsPerSample) {
        return pcmSamplesGeneratedFromXaAdpcmSector(iBitsPerSample) * 2;
    }

    /** The number of Sound Groups in a ADPCM audio sector = 18. */
    public static final int ADPCM_SOUND_GROUPS_PER_SECTOR = 18;

    public static final int SIZE_OF_SOUND_GROUP = 128;

    ////////////////////////////////////////////////////////////////////////////

    /** Class to decode all the sound groups in the ADPCM stream. */
    private final AdpcmSoundGroup _soundGroup;

    /** Number of ADPCM sample frames read from the input.
     * Only incremented once for stereo. Used to help find where in the output
     * stream to look for corruption. */
    protected long _lngSamplesRead = 0;
    
    private XaAdpcmDecoder(int iBitsPerSample) {
        // create one sound group to handle the decoding process
        if (iBitsPerSample == 8)
            _soundGroup = new SoundGroup8BitsPerSample();
        else if (iBitsPerSample == 4)
            _soundGroup = new SoundGroup4BitsPerSample();
        else
            throw new IllegalArgumentException("Invalid bits per sample.");
    }

    /** Temporarily stores a logger to log errors when decoding. */
    private Logger _log;
    /** Temporarily stores a log context when decoding. */
    private String _sLogContext;

    /** Decodes a sector's worth of ADPCM data.
     *  Reads 2304 bytes and writes either 4032 or 8064 bytes. 
     * @param sLogContext String to prepend when logging. May be null.
     */
    public void decode(InputStream inStream, OutputStream out, Logger log, String sLogContext)
            throws IOException
    {
        // There are 18 sound groups,
        // each having  16 bytes of interleaved sound parameters,
        //         and 112 bytes of interleaved ADPCM data
        // ( 18*(16+112) = 2304 bytes will be read )
        try {
            _log = log;
            _sLogContext = sLogContext;
            for (int iSoundGroup = 0; iSoundGroup < ADPCM_SOUND_GROUPS_PER_SECTOR; iSoundGroup++) {
                _soundGroup.readSoundGroup(inStream);
                adpcmSoundGroupToPcm(_soundGroup, out);
            }
        } finally {
            _log = null;
            _sLogContext = null;
        }
    }

    /** Finishes converting the ADPCM samples to PCM and writes them to the buffer. */
    abstract protected void adpcmSoundGroupToPcm(AdpcmSoundGroup soundGroup, OutputStream out)
            throws IOException;

    /** Returns the volume scale that PCM samples are multiplied by before being clamped. */
    abstract public double getVolume();

    /** Sets the volume scale that PCM samples are multiplied by before being clamped. */
    abstract public void setVolume(double dblVolume);

    /** Returns if the decoder is outputting stereo audio. */
    abstract public boolean isStereo();

    /** Resets the decoding context(s). */
    abstract public void resetContext();

    abstract public AudioFormat getOutputFormat(int iSampleRate);
    
    //########################################################################//
    //## Concrete implementations ############################################//
    //########################################################################//

    /** Mono implementation. */
    private static class XaAdpcmDecoder_Mono extends XaAdpcmDecoder {

        private final AdpcmContext _monoContext;

        public XaAdpcmDecoder_Mono(int iBitsPerSample, double dblVolume) {
            super(iBitsPerSample);
            _monoContext = new AdpcmContext(dblVolume);
        }

        public void resetContext() {
            _lngSamplesRead = 0;
            _monoContext.reset();
        }

        public boolean isStereo() {
            return false;
        }

        public double getVolume() {
            return _monoContext.getVolumeScale();
        }

        public void setVolume(double dblVolume) {
            _monoContext.setVolumeScale(dblVolume);
        }


        public void adpcmSoundGroupToPcm(AdpcmSoundGroup soundGroup, OutputStream out) 
                throws IOException
        {
            for (int iSoundUnitIdx = 0; iSoundUnitIdx < soundGroup.getSoundUnitCount(); iSoundUnitIdx++) {
                AdpcmSoundUnit soundUnit = soundGroup.getSoundUnit(iSoundUnitIdx);
                for (int iSample = 0; iSample < AdpcmSoundUnit.SAMPLES_PER_SOUND_UNIT; iSample++) {
                    IO.writeInt16LE(out, soundUnit.readPCMSample(_monoContext));
                }
            }
        }

        public AudioFormat getOutputFormat(int iSampleRate) {
            return new AudioFormat(iSampleRate, 16, 1, true, false);
        }
    }

    //########################################################################//

    /** Stereo implementation. */
    private static class XaAdpcmDecoder_Stereo extends XaAdpcmDecoder {

        private final AdpcmContext _leftContext;
        private final AdpcmContext _rightContext;

        public XaAdpcmDecoder_Stereo(int iBitsPerSample, double dblVolume) {
            super(iBitsPerSample);
            _leftContext = new AdpcmContext(dblVolume);
            _rightContext = new AdpcmContext(dblVolume);
        }

        public void resetContext() {
            _lngSamplesRead = 0;
            _leftContext.reset();
            _rightContext.reset();
        }

        public boolean isStereo() {
            return true;
        }

        public double getVolume() {
            // assume same volume for right channel as well (if it has one)
            return _leftContext.getVolumeScale();
        }

        public void setVolume(double dblVolume) {
            _leftContext.setVolumeScale(dblVolume);
            _rightContext.setVolumeScale(dblVolume);
        }

        public void adpcmSoundGroupToPcm(AdpcmSoundGroup soundGroup, OutputStream out)
                throws IOException
        {
            for (int iSoundUnitIdx = 0; iSoundUnitIdx < soundGroup.getSoundUnitCount(); iSoundUnitIdx+=2) {
                AdpcmSoundUnit leftSoundUnit  = soundGroup.getSoundUnit(iSoundUnitIdx  );
                AdpcmSoundUnit rightSoundUnit = soundGroup.getSoundUnit(iSoundUnitIdx+1);
                for (int iSample = 0; iSample < AdpcmSoundUnit.SAMPLES_PER_SOUND_UNIT; iSample++) {
                    IO.writeInt16LE(out,  leftSoundUnit.readPCMSample(_leftContext ));
                    IO.writeInt16LE(out, rightSoundUnit.readPCMSample(_rightContext));
                }
            }
        }

        public AudioFormat getOutputFormat(int iSampleRate) {
            return new AudioFormat(iSampleRate, 16, 2, true, false);
        }
    }


    /** A sound group has 16 bytes of sound parameters, followed by 112 bytes
     *  of interleaved ADPCM audio data. */
    protected abstract class AdpcmSoundGroup {

        /** Length will be the number of sound units per sound group. */
        protected final AdpcmSoundUnit _aoSoundUnits[];
        protected final byte[] _abParameterBuffer = new byte[16];

        /** Initialize with the requested number of sound units (should be 4 or 8). */
        protected AdpcmSoundGroup(int iSoundUnitsPerSoundGroup) {
            _aoSoundUnits = new AdpcmSoundUnit[iSoundUnitsPerSoundGroup];
            for (int iSoundUnit = 0; iSoundUnit < _aoSoundUnits.length; iSoundUnit++) {
                _aoSoundUnits[iSoundUnit] = new AdpcmSoundUnit();
            }
        }

        public AdpcmSoundUnit getSoundUnit(int i) {
            return _aoSoundUnits[i];
        }

        public int getSoundUnitCount() {
            return _aoSoundUnits.length;
        }

        /** Reads 16 bytes of sound parameters, followed by
         *  112 bytes of interleaved sound units.
         *  Each sound unit will produce 28 PCM samples. */
        abstract protected void readSoundGroup(InputStream inStream)
                throws IOException;

    }

    ////////////////////////////////////////////////////////////////////////
    // Concrete implementations ////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////

    /** {@inheritDoc}
     *
     * When the audio is stored in 8 bits/sample, the audio is interleaved
     * between 4 sound units. */
    private class SoundGroup8BitsPerSample extends AdpcmSoundGroup {

        public static final int SOUND_UNITS_IN_8_BIT_SECTOR = 4;

        public SoundGroup8BitsPerSample() {
            // 4 sound units when 8 bits/sample
            super(SOUND_UNITS_IN_8_BIT_SECTOR);
        }

        /** {@inheritDoc}
         *
         * For 8 bits/sample, there are only 4 sound units that each
         * produce 28 PCM samples.
         */
        protected void readSoundGroup(InputStream inStream)
                throws IOException
        {
            // Process the 16 byte sound parameters at the
            // start of each sound group
            // the 4 sound parameters (one for each sound unit)
            // are repeated four times and are ordered like this:
            // 0,1,2,3, 0,1,2,3, 0,1,2,3, 0,1,2,3

            IO.readByteArray(inStream, _abParameterBuffer);

            for (int iSoundUnit = 0; iSoundUnit < 4; iSoundUnit++) {
                AdpcmSoundUnit soundUnit = _aoSoundUnits[iSoundUnit];
                for (int iRepeat = iSoundUnit; iRepeat < 16; iRepeat+=4) {
                    soundUnit.addSoundParamter(_abParameterBuffer[iRepeat] & 0xff);
                }
                soundUnit.finalizeSoundParamter();
            }

            // de-interleave the sound units
            for (int iSampleIdx = 0; 
                 iSampleIdx < AdpcmSoundUnit.SAMPLES_PER_SOUND_UNIT;
                 iSampleIdx++, _lngSamplesRead++)
            {
                // read a sample for each of the 4 sound units
                for (int iSoundUnit = 0; iSoundUnit < 4;  iSoundUnit++) {
                    int iByte = inStream.read();
                    if (iByte < 0)
                        throw new EOFException("Unexpected end of audio data");
                    // sound unit bytes are interleaved like this
                    // 0,1,2,3, 0,1,2,3, 0,1,2,3 ...
                    // 1 sample for one sound unit per byte

                    _aoSoundUnits[iSoundUnit].writeADPCMSample(
                        (short)(iByte << 8)); // shift the byte into the top of a short
                }
            }
        }

    }

    /** {@inheritDoc}
     *
     * When the audio is stored in 4 bits/sample, the audio is interleaved
     * between 8 sound units. */
    private class SoundGroup4BitsPerSample extends AdpcmSoundGroup {

        public static final int SOUND_UNITS_IN_4_BIT_SECTOR = 8;

        public SoundGroup4BitsPerSample() {
            // 8 sound units when 4 bits/sample
            super(SOUND_UNITS_IN_4_BIT_SECTOR);
        }

        /** {@inheritDoc}
         *
         * For 4 bits/sample, there are 8 sound units that each
         * produce 28 PCM samples. */
        protected void readSoundGroup(InputStream inStream)
                throws IOException
        {
            // Process the 16 byte sound parameters at the
            // start of each sound group
            // the 8 sound parameters (one for each sound unit)
            // are repeated twice, and are ordered like this:
            // 0,1,2,3, 0,1,2,3, 4,5,6,7, 4,5,6,7

            IO.readByteArray(inStream, _abParameterBuffer);

            for (int iSoundUnit = 0; iSoundUnit < 4; iSoundUnit++) {
                _aoSoundUnits[iSoundUnit].addSoundParamter(_abParameterBuffer[iSoundUnit] & 0xff);
                _aoSoundUnits[iSoundUnit].addSoundParamter(_abParameterBuffer[iSoundUnit+4] & 0xff);
                _aoSoundUnits[iSoundUnit].finalizeSoundParamter();

                _aoSoundUnits[iSoundUnit+4].addSoundParamter(_abParameterBuffer[iSoundUnit+8] & 0xff);
                _aoSoundUnits[iSoundUnit+4].addSoundParamter(_abParameterBuffer[iSoundUnit+12] & 0xff);
                _aoSoundUnits[iSoundUnit+4].finalizeSoundParamter();
            }

            // de-interleave the sound units
            for (int iSampleIdx = 0; 
                 iSampleIdx < AdpcmSoundUnit.SAMPLES_PER_SOUND_UNIT;
                 iSampleIdx++, _lngSamplesRead++)
            {
                // read a sample for each of the 8 sound units
                for (int iSoundUnit = 0; iSoundUnit < 8;)
                {
                    int iByte = inStream.read();
                    if (iByte < 0)
                        throw new EOFException("Unexpected end of audio data");

                    // sound unit bytes are interleaved like this
                    // 1/0,3/2,5/4,7/6, 1/0,3/2,5/4,7/6, ...
                    // 1 byte produces two samples, but for different sound units

                    short siADPCMSample;

                    // shift the nibble into the top of a short
                    siADPCMSample = (short)((iByte & 0x0F) << 12);
                    _aoSoundUnits[iSoundUnit].writeADPCMSample(siADPCMSample);
                    iSoundUnit++;
                    // shift the nibble into the top of a short
                    siADPCMSample = (short)((iByte & 0xF0) << 8);
                    _aoSoundUnits[iSoundUnit].writeADPCMSample(siADPCMSample);
                    iSoundUnit++;
                }
            }
        }
    }

    /** Standard K0 multiplier (don't ask me, it's just how it is). */
    private static final double[] SoundUnit_K0 = {
        0.0,
        0.9375,
        1.796875,
        1.53125
    };

    /** Standard K1 multiplier (don't ask me, it's just how it is). */
    private static final double[] SoundUnit_K1 = {
        0.0,
        0.0,
        -0.8125,
        -0.859375
    };

    /** Sound unit found in a sound group. Maintains its ADPCM parameter
     * from the Sound Group parameters, and has a buffer to hold the
     * deinterleaved ADPCM samples for this sound unit.
     *<p>
     * Each Sound Unit generates 28 PCM samples. */
    protected class AdpcmSoundUnit {

        /** The number of ADPCM (as well as PCM) samples per sound unit. */
        public static final int SAMPLES_PER_SOUND_UNIT = 28;

        /** Holds the non-interleaved ADPCM samples for this sound-unit.  */
        private final short[] _asiAdpcmSamples = new short[SAMPLES_PER_SOUND_UNIT];

        private final RobustSoundParameter _soundParameter = new RobustSoundParameter();

        /** The 'range' parameter. How many bits to
         * shift the ADPCM sample to the left. */
        private byte _bParameter_Range;
        /** The 'filter' index parameter. Which K0 and K1 table index to
         *  multiply the previous two ADPCM samples by. */
        private byte _bParameter_FilterIndex;
        
        /** Writing buffer index. Reset once reading starts. */
        private int _iWritePos = 0;
        /** Reading buffer index. Reset once writing starts. */
        private int _iReadPos = 0;

        /** @param iSoundParameter  An unsigned byte value holding the range and
         *                          filter parameters for this sound unit. */
        public void addSoundParamter(int iSoundParameter) {
            _soundParameter.add(iSoundParameter);
        }

        /** After adding redundant sound parameters, this method MUST be called
         * to choose the best one. */
        public void finalizeSoundParamter() {
            int iSoundParameter = _soundParameter.getBestParameter();
            _bParameter_Range       = (byte)(iSoundParameter & 0xF);
            _bParameter_FilterIndex = (byte)((iSoundParameter >>> 4) & 0x3);
        }

        /** Write an ADPCM sample to the internal buffer. */
        public void writeADPCMSample(short siSample) {
            _asiAdpcmSamples[_iWritePos] = siSample;
            _iWritePos++;
            _iReadPos = 0;
        }

        /** Taking de-interleaved sound unit data, the sound parameter for that
         *  unit, and the decoding context (for the previous 2 samples read),
         *  we can convert an entire sound unit.
         * Converts sound samples as they are read. */
        public short readPCMSample(AdpcmContext context) {
            short siADPCM_sample = _asiAdpcmSamples[_iReadPos];
            _iReadPos++;
            _iWritePos = 0;

            // shift sound data according to the range, keeping the sign
            long lngResult = (siADPCM_sample >> _bParameter_Range);

            // adjust according to the filter
            double dblResult = lngResult +
                SoundUnit_K0[_bParameter_FilterIndex] * context.getPreviousPCMSample1() +
                SoundUnit_K1[_bParameter_FilterIndex] * context.getPreviousPCMSample2();

            // let the context scale, round, and clamp
            // fianlly return the polished sample
            return context.saveScaleRoundClampPCMSample(dblResult);
        }
    }


    /** Picks the best sound parameter. */
    private class RobustSoundParameter {

        /** A simple object pool. */
        private final SoundParameter[] _aoParameterPool = {
            new SoundParameter(0),
            new SoundParameter(1),
            new SoundParameter(2),
            new SoundParameter(3),
        };

        private int _iPoolIndex = 0;

        private final ArrayList<SoundParameter> _uniqueParameters =
                new ArrayList<SoundParameter>(4);

        /** Add a redundant sound parameter value for this class to choose the
         * best one from. */
        public void add(int iValue) {
            SoundParameter param = _aoParameterPool[_iPoolIndex];
            _iPoolIndex++;
            param.set(iValue);
            for (int i = 0; i < _uniqueParameters.size(); i++) {
                if (_uniqueParameters.get(i).addIfEquals(param))
                    return;
            }
            _uniqueParameters.add(param);
        }

        /** Returns best parameter of all the parameters that were added since
         * this method was last called. Resets the class. */
        public int getBestParameter() {
            if (_uniqueParameters.size() > 1) {
                Collections.sort(_uniqueParameters);
                if (_log != null && _log.isLoggable(Level.WARNING)) {
                    // corruption!
                    StringBuilder sb = new StringBuilder();
                    if (_sLogContext != null)
                        sb.append(_sLogContext);
                    for (int i = 0; i < _uniqueParameters.size(); i++) {
                        _uniqueParameters.get(i).report(sb);
                        sb.append('.');
                    }
                    sb.append(" Chose [").append(_uniqueParameters.get(0).getIndex()).append("]. Affects samples starting at ").append(_lngSamplesRead);
                    _log.warning(sb.toString());
                }
            } else if (!_uniqueParameters.get(0).isValid() && _log != null && _log.isLoggable(Level.WARNING)) {
                StringBuilder sb = new StringBuilder();
                if (_sLogContext != null)
                    sb.append(_sLogContext);
                _uniqueParameters.get(0).report(sb);
                sb.append(". Affects samples starting at ").append(_lngSamplesRead);
                _log.warning(sb.toString());
            }
            int iChosen = _uniqueParameters.get(0).getValue();
            _uniqueParameters.clear();
            _iPoolIndex = 0;
            return iChosen;
        }

        /** ADPCM sound parameter. */
        private class SoundParameter implements Comparable<SoundParameter> {
            /** Index of this redundant sound parameter. */
            private final int _iIndex;
            private int _iValue;
            private boolean _blnIsValid;
            /** Stores any other redundant sound parameters with the same value. */
            private final ArrayList<SoundParameter> _duplicates = new ArrayList<SoundParameter>(3);

            public SoundParameter(int iIndex) {
                _iIndex = iIndex;
            }

            /** Sets the parameter value and resets the class. */
            public void set(int i) {
                _iValue = i;
                _blnIsValid = (_iValue & 0x80) == 0;
                _duplicates.clear();
            }

            public int getIndex() {
                return _iIndex;
            }

            public int getValue() {
                return _iValue;
            }

            public boolean isValid() {
                return _blnIsValid;
            }
            
            /** Checks if other SoundParameter has the same value. If so, add it
             * to the internal list of duplicates.
             * @return if other SoundParameter has the same value. */
            public boolean addIfEquals(SoundParameter other) {
                if (other._iValue == _iValue) {
                    _duplicates.add(other);
                    return true;
                }
                return false;
            }

            /** Returns a readable summary of this SoundParameter and any duplicates. */
            public void report(StringBuilder sb) {
                sb.append('[').append(_iIndex).append(']');
                for (int i = 0; i < _duplicates.size(); i++) {
                    sb.append(",[").append(_duplicates.get(i)._iIndex).append(']');
                }
                sb.append('=').append(Misc.bitsToString(_iValue, 8));
                if (!_blnIsValid)
                    sb.append(" (bad)");
            }

            /** Sorts valid values first, then by index.
             * This should put the best SoundParameter as the first item. */
            // [implements Comparable]
            public int compareTo(SoundParameter other) {
                if (_blnIsValid && !other._blnIsValid)
                    return -1;
                if (!_blnIsValid && other._blnIsValid)
                    return 1;
                if (_iValue == other._iValue)
                    throw new IllegalStateException(
                            "Logic of RobustSoundParameter.add() must be wrong.");
                if (_iIndex < other._iIndex)
                    return -1;
                else
                    return 1;
            }

            public String toString() {
                StringBuilder sb = new StringBuilder();
                report(sb);
                return sb.toString();
            }

        }

    }

}
